using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using FunctionApp.DataAccess;
using FunctionApp.Models;
using FunctionApp.Models.Options;
using FunctionApp.Services;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Azure.Communication.Email;
using System.Linq;
using Azure;

namespace FunctionApp.Functions
{
    /// <summary>
    /// Stores logs generated by the data factory (or other callers) into the default logging implemented by the
    ///  Azure Function (App Insights)
    /// </summary>
    public class AdfLogging
    {
        private readonly IOptions<ApplicationOptions> _options;
        private readonly TaskMetaDataDatabase _taskMetaDataDatabase;

        public AdfLogging(IOptions<ApplicationOptions> options, TaskMetaDataDatabase taskMetaDataDatabase)
        {
            _options = options;
            _taskMetaDataDatabase = taskMetaDataDatabase;
        }
        [FunctionName("Log")]
        public async Task<IActionResult> Run(
            [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
            ILogger log, ExecutionContext context)
        {
            Guid executionId = context.InvocationId;
            FrameworkRunner frp = new FrameworkRunner(log, executionId);

            FrameworkRunnerWorkerWithHttpRequest worker = LogCore;
            FrameworkRunnerResult result = await frp.Invoke(req, "Log", worker);
            if (result.Succeeded)
            {
                return new OkObjectResult(JObject.Parse(result.ReturnObject));
            }
            else
            {
                return new BadRequestObjectResult(new { Error = "Execution Failed...." });
            }

        }
        public async Task<JObject> LogCore(HttpRequest req,
            Logging.Logging LogHelper)
        {
            //short frameworkNumberOfRetries = _options.Value.FrameworkNumberOfRetries;
            short frameworkNumberOfRetries = 1;

            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            dynamic data = JsonConvert.DeserializeObject(requestBody);

            dynamic taskInstanceId = data["TaskInstanceId"];
            dynamic taskMasterId = data["TaskMasterId"];
            dynamic taskMasterName = data["TaskMasterName"];
            dynamic numberOfRetries = data["NumberOfRetries"];
            dynamic postObjectExecutionUid = data["ExecutionUid"];
            dynamic adfRunUid = data["RunId"];
            dynamic logTypeId = data["LogTypeId"];//1 Error, 2 Warning, 3 Info, 4 Performance, 5 Debug
            dynamic logSource = data["LogSource"];//ADF, AF
            dynamic activityType = data["ActivityType"];
            dynamic startDateTimeOffSet = data["StartDateTimeOffSet"];
            dynamic status = data["Status"]; //Started Failed Completed
            dynamic comment = data["Comment"];
            comment = comment == null ? "" : comment.ToString();
            comment = System.Web.HttpUtility.UrlDecode(comment);
            dynamic endDateTimeOffSet = data["EndDateTimeOffSet"];
            dynamic rowsInserted = data["RowsInserted"];
            dynamic NotificationList = data["NotificationList"];
            dynamic NotificationOn = data["NotificationOn"];
            string notificationOn = "";
            string notificationList = "";

            if (taskInstanceId != null) { LogHelper.DefaultActivityLogItem.TaskInstanceId = (long?)taskInstanceId; }
            if (logSource != null) { LogHelper.DefaultActivityLogItem.LogSource = (string)logSource; }
            if (logTypeId != null) { LogHelper.DefaultActivityLogItem.LogTypeId = (short?)logTypeId; }
            if (startDateTimeOffSet != null) { LogHelper.DefaultActivityLogItem.StartDateTimeOffset = (DateTimeOffset)startDateTimeOffSet; }
            if (status!= null) { LogHelper.DefaultActivityLogItem.Status = (string)status; }
            if (endDateTimeOffSet != null) { LogHelper.DefaultActivityLogItem.EndDateTimeOffset = (DateTimeOffset)endDateTimeOffSet; }
            if (postObjectExecutionUid != null) { LogHelper.DefaultActivityLogItem.ExecutionUid = (Guid?)postObjectExecutionUid; }
            if (NotificationOn is null) { notificationOn = "Disabled"; } else { notificationOn = NotificationOn.ToString(); }
            if (NotificationList != null) { notificationList = NotificationList.ToString(); }

            LogHelper.LogInformation(comment);

            if (activityType == "Data-Movement-Master")
            {
                TaskInstance.TaskStatus taskStatus;
                if (status == "Failed")
                {
                    //Todo Put Max Number of retries in DB at TaskMasterLevel -- This has now been done. Have left logic in function as stored procedure handles with all failed statuses. 
                    numberOfRetries = (numberOfRetries == null) ? 0 : (int)numberOfRetries + 1;
                    taskStatus = ((numberOfRetries < frameworkNumberOfRetries) ? TaskInstance.TaskStatus.FailedRetry : TaskInstance.TaskStatus.FailedNoRetry);

                }
                else
                {
                    if (Enum.TryParse<TaskInstance.TaskStatus>(status.ToString(), out taskStatus) == false)
                    {
                        string invalidStatus = $"TaskStatus Enum does not exist for: {status}";
                        LogHelper.LogErrors(new Exception(invalidStatus));
                        comment = string.Concat(comment,".",invalidStatus);
                        taskStatus = TaskInstance.TaskStatus.FailedNoRetry;
                    }
                }
                await _taskMetaDataDatabase.LogTaskInstanceCompletion((Int64)taskInstanceId, (Guid)postObjectExecutionUid, taskStatus, (Guid)adfRunUid, (String)comment);
                try
                {
                    if (notificationList != null & notificationOn != "Disabled")
                    {
                        var boolEmail = false;
                        var subject = "";
                        var htmlContent = "";
                        switch (notificationOn)
                        {
                            case "Completion":
                                boolEmail = true;
                                subject = $"Task Completion Notification: {taskMasterName}";
                                htmlContent = $"<html><body><h1>Task Completed</h1>";
                                break;
                            case "Success":
                                if (status == "Complete")
                                {
                                    boolEmail = true;
                                    subject = $"Task Success Notification: {taskMasterName}";
                                    htmlContent = $"<html><body><h1>Task Successful</h1>";
                                }
                                break;
                            case "Failure":
                                if (status == "Failed")
                                {
                                    boolEmail = true;
                                    subject = $"Task Failure Notification: {taskMasterName}";
                                    htmlContent = $"<html><body><h1>Task Failure</h1>";
                                }
                                break;
                            case "FailureNoRetry":
                                if (status == "Failed" && numberOfRetries >= frameworkNumberOfRetries)
                                {
                                    boolEmail = true;
                                    subject = $"Task Failure (No Retry) Notification: {taskMasterName}";
                                    htmlContent = $"<html><body><h1>Task Failure (No Retry)</h1>";

                                }
                                break;
                        }
                        if (boolEmail)
                        {
                            // Separate emails
                            //notificationList = Regex.Replace(notificationList, @"\s+", "");
                            LogHelper.LogInformation($"Email notification list = {notificationList}");
                            notificationList = notificationList.Replace(" ", String.Empty);
                            var emailAddresses = notificationList.Split(',').ToList();
                            emailAddresses = emailAddresses.Distinct().ToList();
                            EmailClient emailClient = new EmailClient(_options.Value.AzureCommunicationsService.ConnectionString);
                            var sender = _options.Value.AzureCommunicationsService.EmailFromAddress;
                            htmlContent = htmlContent + $"<br/><b>Task Master Name:</b> {taskMasterName}<br/><b>Task Master Id:</b> {taskMasterId}<br/><b>Task Instance Id:</b> {taskInstanceId}<br/><b>Task Start (UTC):</b> {startDateTimeOffSet}<br/><b>Task End (UTC):</b> {endDateTimeOffSet}<br/><b>Run Uid:</b> {adfRunUid}<br/><b>Status:</b> {status}<br/><b>Retries:</b> {numberOfRetries}";
                            htmlContent = htmlContent + "<p>This mail was sent automatically as part of the ADS Go Fast Framework.</p></body></html>";
                            foreach (var email in emailAddresses)
                            {
                                var recipient = email;
                                try
                                {
                                    Console.WriteLine("Sending email...");
                                    EmailSendOperation emailSendOperation = await emailClient.SendAsync(
                                        Azure.WaitUntil.Completed,
                                        sender,
                                        recipient,
                                        subject,
                                        htmlContent).ConfigureAwait(false);
                                    EmailSendResult statusMonitor = emailSendOperation.Value;

                                    LogHelper.LogInformation($"Email Sent. Status = {emailSendOperation.Value.Status}");

                                    /// Get the OperationId so that it can be used for tracking the message for troubleshooting
                                    string operationId = emailSendOperation.Id;
                                    LogHelper.LogInformation($"Email operation id = {operationId}");
                                }
                                catch (RequestFailedException ex)
                                {
                                    /// OperationID is contained in the exception message and can be used for troubleshooting purposes
                                    LogHelper.LogInformation($"Email send operation failed with error code: {ex.ErrorCode}, message: {ex.Message}");
                                }
                            }


                        }
                    }
                } 
                catch (Exception e) 
                {
                    LogHelper.LogErrors(e);
                }
            }

            return new JObject
            {
                ["Result"] = "Complete"
            };
        }
    }
}